<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Knowledge Base | Dr. Vladimir Petukhov</title>
    <meta name="description" content="A portfolio site as a general C++/Python programmer, general algorithms developer, industrial computer vision engineer, machine learning engineer and web apps developer.">
    <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-6HX7S00F14"></script>
  <script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6HX7S00F14');</script>
    
    <link rel="preload" href="/assets/css/0.styles.3cbb11d5.css" as="style"><link rel="preload" href="/assets/js/app.ce984737.js" as="script"><link rel="preload" href="/assets/js/8.894e6ddb.js" as="script"><link rel="prefetch" href="/assets/js/10.3f793c3b.js"><link rel="prefetch" href="/assets/js/11.7d1838ae.js"><link rel="prefetch" href="/assets/js/12.fa0d23c3.js"><link rel="prefetch" href="/assets/js/13.2c4402ac.js"><link rel="prefetch" href="/assets/js/14.80981750.js"><link rel="prefetch" href="/assets/js/15.9142cbf1.js"><link rel="prefetch" href="/assets/js/2.0516d3d1.js"><link rel="prefetch" href="/assets/js/3.b232311c.js"><link rel="prefetch" href="/assets/js/4.e81f98d2.js"><link rel="prefetch" href="/assets/js/5.20e5b81e.js"><link rel="prefetch" href="/assets/js/6.e9be5358.js"><link rel="prefetch" href="/assets/js/7.942eef89.js"><link rel="prefetch" href="/assets/js/9.c096d266.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3cbb11d5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Dr. Vladimir Petukhov</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Projects/" class="nav-link">Projects</a></div><div class="nav-item"><a href="/KnowledgeBase/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Knowledge Base</a></div><div class="nav-item"><a href="/Curriculum/" class="nav-link">Curriculum Vitae</a></div><div class="nav-item"><a href="/ComputerScienceSkills/" class="nav-link">Computer Science Skills</a></div><div class="nav-item"><a href="/Publications/" class="nav-link">Publications</a></div><div class="nav-item"><a href="/Certifications/" class="nav-link">Certifications</a></div><div class="nav-item"><a href="/Readings/" class="nav-link">Readings</a></div><div class="nav-item"><a href="/Contact/" class="nav-link">Contact and Availability</a></div><div class="nav-item"><a href="https://github.com/vperepos" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Projects/" class="nav-link">Projects</a></div><div class="nav-item"><a href="/KnowledgeBase/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Knowledge Base</a></div><div class="nav-item"><a href="/Curriculum/" class="nav-link">Curriculum Vitae</a></div><div class="nav-item"><a href="/ComputerScienceSkills/" class="nav-link">Computer Science Skills</a></div><div class="nav-item"><a href="/Publications/" class="nav-link">Publications</a></div><div class="nav-item"><a href="/Certifications/" class="nav-link">Certifications</a></div><div class="nav-item"><a href="/Readings/" class="nav-link">Readings</a></div><div class="nav-item"><a href="/Contact/" class="nav-link">Contact and Availability</a></div><div class="nav-item"><a href="https://github.com/vperepos" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Knowledge Base</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/KnowledgeBase/#possible-interview-questions" class="sidebar-link">Possible interview questions.</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/KnowledgeBase/#interview-questions-for-algorithms-and-data-structures" class="sidebar-link">Interview questions for algorithms and data structures.</a></li><li class="sidebar-sub-header"><a href="/KnowledgeBase/#interview-questions-for-c" class="sidebar-link">Interview questions for C++.</a></li><li class="sidebar-sub-header"><a href="/KnowledgeBase/#interview-questions-for-python" class="sidebar-link">Interview questions for Python.</a></li><li class="sidebar-sub-header"><a href="/KnowledgeBase/#interview-questions-for-computer-vision" class="sidebar-link">Interview questions for Computer Vision.</a></li><li class="sidebar-sub-header"><a href="/KnowledgeBase/#interview-questions-for-machine-learning" class="sidebar-link">Interview questions for Machine Learning.</a></li><li class="sidebar-sub-header"><a href="/KnowledgeBase/#interview-questions-for-software-engineering-architecture-and-design" class="sidebar-link">Interview questions for Software Engineering, Architecture and Design.</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="knowledge-base"><a href="#knowledge-base" class="header-anchor">#</a> Knowledge Base</h1> <h2 id="possible-interview-questions"><a href="#possible-interview-questions" class="header-anchor">#</a> Possible interview questions.</h2> <p><strong>Sources:</strong><br>
www.simplilearn.com/data-structure-interview-questions-and-answers-article <br>
www.wikipedia.com <br></p> <h3 id="interview-questions-for-algorithms-and-data-structures"><a href="#interview-questions-for-algorithms-and-data-structures" class="header-anchor">#</a> Interview questions for algorithms and data structures.</h3> <h4 id="_1-what-is-a-data-structure"><a href="#_1-what-is-a-data-structure" class="header-anchor">#</a> 1. What is a data structure?</h4> <p>In computer science, a data structure is a <strong>data organization</strong>, and storage format that is usually chosen <strong>for efficient access</strong> to data.<br></p> <h4 id="_2-describe-the-types-of-data-structures"><a href="#_2-describe-the-types-of-data-structures" class="header-anchor">#</a> 2. Describe the types of data structures?</h4> <ul><li><strong>Array</strong> - an array is a number of elements in a specific order, typically all of the same type. Elements are accessed using an integer index to specify which element is required.<br></li> <li><strong>List</strong> - a linked list is a linear collection of data elements of any type, called nodes, where each node has itself a value, and points to the next node in the linked list. The principal advantage of a linked list over an array is that values can always be efficiently inserted and removed without relocating the rest of the list. Certain other operations, such as random access to a certain element, are however slower on lists than on arrays.<br></li> <li><strong>Record</strong> - a record (also <strong>called tuple</strong> or <strong>struct</strong>) is an <strong>aggregate data structure</strong>. A record is a value that contains other values, typically in fixed number and sequence and typically indexed by names. The elements of records are usually called fields or members. In the context of object-oriented programming, records are known as plain old data structures to distinguish them from objects. <br></li> <li><strong>Hash tables</strong> -  also known as hash maps, are data structures that provide fast retrieval of values based on keys. They use a hashing function to map keys to indexes in an array, allowing for constant-time access in the average case. Hash tables are commonly used in dictionaries, caches, and database indexing. However, hash collisions can occur, which can impact their performance. Techniques like chaining and open addressing are employed to handle collisions.<br></li> <li><strong>Graphs</strong> - collections of nodes connected by edges, representing relationships between entities. They consist of vertices (nodes) and edges (connections between nodes). Graphs can be directed or undirected, and they can have cycles or be acyclic.<br></li> <li><strong>Stacks and queues</strong> - abstract data types that can be implemented using arrays or linked lists. A stack has two primary operations: push (adds an element to the top of the stack) and pop (removes the topmost element from the stack), that follow the Last In, First Out (LIFO) principle. Queues have two main operations: enqueue (adds an element to the rear of the queue) and dequeue (removes an element from the front of the queue) that follow the First In, First Out (FIFO) principle.<br></li> <li><strong>Trees</strong> - represent a hierarchical organization of elements. A tree consists of nodes connected by edges, with one node being the root and all other nodes forming subtrees. <strong>Binary trees</strong> (particularly heaps), <strong>AVL trees</strong>, and <strong>B-trees</strong> are some popular types of trees. They enable efficient and optimal searching, sorting, and hierarchical representation of data.</li> <li><strong>Trie</strong> - also known as a <strong>prefix tree</strong>, is a specialized tree data structure used for the efficient retrieval of strings. Tries store characters of a string as nodes, with each edge representing a character. They are particularly useful in text processing scenarios like autocomplete, spell-checking, and dictionary implementations. Tries enable fast searching and prefix-based operations on strings.<br></li></ul> <h4 id="_3-what-is-a-linear-data-structure-name-a-few-examples"><a href="#_3-what-is-a-linear-data-structure-name-a-few-examples" class="header-anchor">#</a> 3. What is a Linear Data Structure? Name a few examples.</h4> <p>A data structure is linear if all its elements or data items are arranged in a sequence or a linear order. The elements are stored in a <strong>non-hierarchical way</strong> so that each item has successors and predecessors except the first and last element in the list.
Examples of linear data structures are <strong>Array</strong>, <strong>Stack</strong>, <strong>Queue</strong>, and <strong>Linked List</strong>.<br></p> <h4 id="_4-how-are-the-elements-of-a-2d-array-stored-in-the-memory"><a href="#_4-how-are-the-elements-of-a-2d-array-stored-in-the-memory" class="header-anchor">#</a> 4. How are the elements of a 2D Array stored in the memory.</h4> <ul><li><strong>Row-Major Order</strong>: In row-major ordering, the first row of a 2D array is entirely stored in memory, followed by the second row of the array, and so on until the final row.</li> <li><strong>Column-Major Order</strong>: In column-major ordering, the first column of the array is entirely saved in memory, followed by the second row of the array, and so on until the last column of the array is fully recorded in the memory.</li></ul> <h4 id="_5-what-are-some-use-cases-for-row-major-and-column-major-storing-of-2d-arrays"><a href="#_5-what-are-some-use-cases-for-row-major-and-column-major-storing-of-2d-arrays" class="header-anchor">#</a> 5. What are some use cases for Row-Major and Column-Major storing of 2D Arrays?</h4> <p><strong>Row-Major</strong> stored arrays are more efficient for row-wise access like in <strong>Image Processing</strong>. <strong>Column-Major</strong> stored arrays are more efficient for column-wise access like for <strong>Matrix Multiplication</strong>.<br></p> <h4 id="_6-how-can-you-possibly-choose-between-row-major-and-column-major-2d-arrays-storing-implementations"><a href="#_6-how-can-you-possibly-choose-between-row-major-and-column-major-2d-arrays-storing-implementations" class="header-anchor">#</a> 6. How can you possibly choose between Row-Major and Column-Major 2D Arrays storing implementations?</h4> <p>By choosing a <strong>programming language</strong>. <strong>Row-Major</strong> is implemented in languages like C/C++ and <strong>Column-Major</strong> - in Fortran.</p> <h4 id="_7-what-is-a-linked-list-data-structure"><a href="#_7-what-is-a-linked-list-data-structure" class="header-anchor">#</a> 7. What is a Linked List Data Structure?</h4> <p>It’s a both <strong>linear and non-linear Data Structure</strong>, depending on application, or a sequence of data objects where <strong>elements are not stored in adjacent memory locations</strong>. The elements are linked using pointers to form a chain. Each element is a separate object, called a node.  Each node has two items: a data field and a reference to the next node. The entry point in a linked list is called the head. Where the list is empty, the head is a null reference and the last node has a reference to null. A linked list is a dynamic data structure, where the number of nodes is not fixed, and the list has the ability to grow and shrink on demand.
It is applied in cases where:</p> <ul><li>We deal with an unknown number of objects or don’t know how many items are in the list</li> <li>We need constant-time insertions/deletions from the list, as in real-time computing where time predictability is critical</li> <li>Random access to any elements is not needed</li> <li>The algorithm requires a data structure where objects need to be stored irrespective of their physical address in memory</li> <li>We need to insert items in the middle of the list as in a priority queue
<br></li></ul> <h4 id="_8-are-linked-lists-considered-linear-or-non-linear-data-structures"><a href="#_8-are-linked-lists-considered-linear-or-non-linear-data-structures" class="header-anchor">#</a> 8. Are Linked Lists considered Linear or Non-linear Data Structures?</h4> <p>Linked lists are considered both linear and non-linear data structures depending upon the application they are used for. When used for access strategies, it is considered as a linear data-structure. When used for data storage, it is considered a non-linear data structure.</p> <h4 id="_9-what-are-the-advantages-of-a-linked-list-over-an-array-in-which-scenarios-do-we-use-linked-list-and-when-array"><a href="#_9-what-are-the-advantages-of-a-linked-list-over-an-array-in-which-scenarios-do-we-use-linked-list-and-when-array" class="header-anchor">#</a> 9. What are the advantages of a Linked List over an Array? In which scenarios do we use Linked List and when Array?</h4> <p>Advantages of a linked list over an array are:</p> <ul><li><p><strong>Insertion and Deletion</strong><br>
Insertion and deletion of nodes is an easier process, as we only update the address present in the next pointer of a node. It’s expensive to do the same in an array as the room has to be created for the new elements and existing elements must be shifted.<br></p></li> <li><p><strong>Dynamic Data Structure</strong><br>
As a linked list is a dynamic data structure, there is no need to give an initial size as it can grow and shrink at runtime by allocating and deallocating memory. However, the size is limited in an array as the number of elements is statically stored in the main memory.<br></p></li> <li><p><strong>No wastage of Memory</strong><br>
As the size of a linked list can increase or decrease depending on the demands of the program, and memory is allocated only when required, there is no memory wasted. In the case of an array, there is memory wastage. For instance, if we declare an array of size 10 and store only five elements in it, then the space for five elements is wasted.<br></p></li> <li><p><strong>Implementation</strong><br>
Data structures like stack and queues are more easily implemented using a linked list than an array.<br></p></li> <li><p><strong>Some scenarios where we use linked list over array are</strong>:</p> <ul><li>When we do not know the upper limit on the number of elements in advance</li> <li>When there are a large number of add or remove operations</li> <li>When there are no large number of random access to elements</li> <li>When we want to insert items in the middle of the list, such as when implementing a priority queue<br></li></ul></li> <li><p><strong>Some scenarios in which we use array over the linked list are</strong>:</p> <ul><li>When we need to index or randomly access elements</li> <li>When we know the number of elements in the array beforehand, so we can allocate the correct amount of memory</li> <li>When we need speed when iterating through all the elements in the sequence</li> <li>When memory is a concern; filled arrays use less memory than linked lists, as each element in the array is the data but each linked list node requires the data as well as one or more pointers to the other elements in the linked list
<br></li></ul></li></ul> <h4 id="_10-what-is-a-doubly-linked-list"><a href="#_10-what-is-a-doubly-linked-list" class="header-anchor">#</a> 10. What is a Doubly-Linked List?</h4> <p>It is a complex type (double-ended LL) of a linked list in which a node has two links, one that connects to the next node in the sequence and another that connects to the previous node. This allows traversal across the data elements in both directions.<br></p> <h4 id="_11-what-are-dynamic-data-structures-name-a-few"><a href="#_11-what-are-dynamic-data-structures-name-a-few" class="header-anchor">#</a> 11. What are Dynamic Data Structures? Name a few.</h4> <p>They are collections of data in memory that expand and contract to grow or shrink in size as a program runs. This enables the programmer to control exactly how much memory is to be utilized. Examples are the <strong>dynamic array</strong>, <strong>linked list</strong>, <strong>stack</strong>, <strong>queue</strong>, and <strong>heap</strong>.<br></p> <h4 id="_12-what-is-a-stack"><a href="#_12-what-is-a-stack" class="header-anchor">#</a> 12. What is a stack?</h4> <p>A stack is an abstract data type that specifies a linear data structure, as in a real physical stack or piles where you can only take the top item off the stack in order to remove things. Thus, insertion (push) and deletion (pop) of items take place only at one end called top of the stack, with a particular order: LIFO (Last In First Out) or FILO (First In Last Out).</p> <h4 id="_13-where-are-stacks-used"><a href="#_13-where-are-stacks-used" class="header-anchor">#</a> 13. Where are stacks used?</h4> <ul><li>Expression, evaluation, or conversion of evaluating prefix, postfix, and infix expressions</li> <li>Syntax parsing</li> <li>String reversal</li> <li>Parenthesis checking</li> <li>Backtracking</li></ul> <h4 id="_14-what-are-the-operations-that-can-be-performed-on-a-stack"><a href="#_14-what-are-the-operations-that-can-be-performed-on-a-stack" class="header-anchor">#</a> 14. What are the operations that can be performed on a stack?</h4> <p>A stack may perform three fundamental operations:</p> <ul><li>PUSH: The push action inserts a new element into the stack. The new feature is placed at the top of the stack.</li> <li>POP: The pop operation is performed to remove the stack's topmost element.</li> <li>PEEK: A peek action returns the value of the stack's topmost element without removing it from the stack.</li></ul> <h4 id="_15-what-is-a-queue-data-structure"><a href="#_15-what-is-a-queue-data-structure" class="header-anchor">#</a> 15. What is a queue Data Structure?</h4> <p>A queue is an abstract data type that specifies a linear data structure or an ordered list,  using the First In First Out (FIFO) operation to access elements. Insert operations can be performed only at one end called REAR and delete operations can be performed only at the other end called FRONT.</p> <h4 id="_16-list-some-applications-of-queue-data-structure"><a href="#_16-list-some-applications-of-queue-data-structure" class="header-anchor">#</a> 16. List some applications of queue Data Structure.</h4> <p>To prioritize jobs as in the following scenarios:</p> <ul><li>As waiting lists for a single shared resource (like printer, CPU, call center systems).</li> <li>In the asynchronous transfer of data (file IO, sockets).</li></ul> <h4 id="_17-what-is-a-dequeue"><a href="#_17-what-is-a-dequeue" class="header-anchor">#</a> 17. What is a Dequeue?</h4> <p>It is a double-ended queue, or a data structure, where the elements can be inserted or deleted at both ends (FRONT and REAR).</p> <h4 id="_18-what-operations-can-be-performed-on-queues"><a href="#_18-what-operations-can-be-performed-on-queues" class="header-anchor">#</a> 18. What operations can be performed on queues?</h4> <ul><li>enqueue() adds an element to the end of the queue</li> <li>dequeue() removes an element from the front of the queue</li> <li>init() is used for initializing the queue</li> <li>isEmpty() tests for whether or not the queue is empty</li> <li>The front is used to get the value of the first data item but does not remove it</li> <li>The rear is used to get the last item from a queue</li></ul> <h4 id="_19-define-the-graph-data-structure"><a href="#_19-define-the-graph-data-structure" class="header-anchor">#</a> 19. Define the graph Data Structure?</h4> <p>It is a type of non-linear data structure that consists of vertices or nodes connected by edges or arcs to enable storage or retrieval of data. Edges may be directed or undirected.</p> <h4 id="_20-what-are-the-applications-of-graph-data-structure"><a href="#_20-what-are-the-applications-of-graph-data-structure" class="header-anchor">#</a> 20. What are the applications of graph Data Structure?</h4> <ul><li>Transport grids where stations are represented as vertices and routes as the edges of the graph</li> <li>Utility graphs of power or water, where vertices are connection points and edge the wires or pipes connecting them</li> <li>Social network graphs to determine the flow of information and hotspots (edges and vertices)</li> <li>Neural networks where vertices represent neurons and edge the synapses between them</li></ul> <h4 id="_21-list-the-types-of-trees"><a href="#_21-list-the-types-of-trees" class="header-anchor">#</a> 21. List the types of trees?</h4> <ul><li><p><strong>The General Tree</strong> <br>
A tree is referred to as a generic tree if its hierarchy is not constrained. In the General Tree, each node can have an endless number of offspring, and all other trees are subsets of the tree.<br></p></li> <li><p><strong>The Binary Tree</strong> <br>
The binary tree is a type of tree in which each parent has at least two offspring. The children are referred to as the left and right youngsters. This tree is more popular than most others. When specific limitations and features are given to a Binary tree, various trees such as AVL tree, BST (Binary Search Tree), RBT tree, and so on are also utilized. <br></p></li> <li><p><strong>Binary Search Tree</strong> <br>
Binary Search Tree (BST) is a binary tree extension that includes numerous optional constraints. In BST, a node's left child value should be less than or equal to the parent value, while the right child value should always be higher than the parent's value.<br></p></li> <li><p><strong>The AVL Tree</strong> <br>
The AVL tree is a self-balancing binary search tree (automatically keeps its height (maximal number of levels below the root) small in the face of arbitrary item insertions and deletions). The term AVL is given in honor of the inventors Adelson-Velshi and Landis. This was the first tree to achieve dynamic equilibrium. Each node in the AVL tree is assigned a balancing factor based on whether the tree is balanced or not. The node kids have a maximum height of one AVL vine. Search, insert, delete operations have O(log n) complexity.<br></p></li> <li><p><strong>Red and Black Tree</strong> <br>
Red-black trees are another type of auto-balancing tree. The red-black term is derived from the qualities of the red-black tree, which has either red or black painted on each node. It helps to keep the forest in balance. Even though this tree is not perfectly balanced, the searching process takes just O(log n) time. <br></p></li> <li><p><strong>The N-ary Tree</strong> <br>
In this sort of tree with a node, N is the maximum number of children. A binary tree is a two-year tree since each binary tree node has no more than two offsprings. A full N-ary tree is one in which the children of each node are either 0 or N. <br></p></li> <li><p><strong>Octree</strong> <br>
An octree is a tree data structure in which each internal node has exactly eight children. Octrees are most often used to partition a three-dimensional space by recursively subdividing it into eight octants.</p></li> <li><p><strong>Heap</strong> <br>
A heap is a tree-based data structure that satisfies the heap property: in a max heap, for any given node C, if P is a parent node of C, then the key (the value) of P is greater than or equal to the key of C. In a min heap, the key of P is less than or equal to the key of C.</p></li></ul> <h4 id="_22-how-is-a-node-height-in-a-tree-data-structure-determined"><a href="#_22-how-is-a-node-height-in-a-tree-data-structure-determined" class="header-anchor">#</a> 22. How is a node height in a Tree Data Structure determined?</h4> <p>The height of the node equals the number of edges in the longest path to the leaf from the node, where the depth of a leaf node is 0.</p> <h4 id="_23-explain-what-jagged-array-is"><a href="#_23-explain-what-jagged-array-is" class="header-anchor">#</a> 23. Explain what Jagged Array is?</h4> <p>It is an array whose elements themselves are arrays and may be of different dimensions and sizes.</p> <h3 id="interview-questions-for-c"><a href="#interview-questions-for-c" class="header-anchor">#</a> Interview questions for C++.</h3> <h3 id="interview-questions-for-python"><a href="#interview-questions-for-python" class="header-anchor">#</a> Interview questions for Python.</h3> <h3 id="interview-questions-for-computer-vision"><a href="#interview-questions-for-computer-vision" class="header-anchor">#</a> Interview questions for Computer Vision.</h3> <h3 id="interview-questions-for-machine-learning"><a href="#interview-questions-for-machine-learning" class="header-anchor">#</a> Interview questions for Machine Learning.</h3> <h3 id="interview-questions-for-software-engineering-architecture-and-design"><a href="#interview-questions-for-software-engineering-architecture-and-design" class="header-anchor">#</a> Interview questions for Software Engineering, Architecture and Design.</h3></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.ce984737.js" defer></script><script src="/assets/js/8.894e6ddb.js" defer></script>
  </body>
</html>
